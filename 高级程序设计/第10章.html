<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>10. 函数 | Croon Liu</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.png">
    <meta name="description" content="Replace the stars and rivers in the body with unlimited methods for the future">
    
    <link rel="preload" href="/assets/css/0.styles.d236ad96.css" as="style"><link rel="preload" href="/assets/js/app.356218c2.js" as="script"><link rel="preload" href="/assets/js/2.1547bbba.js" as="script"><link rel="preload" href="/assets/js/21.f4053037.js" as="script"><link rel="prefetch" href="/assets/js/10.7d9019c4.js"><link rel="prefetch" href="/assets/js/11.2b41e043.js"><link rel="prefetch" href="/assets/js/12.23bc9545.js"><link rel="prefetch" href="/assets/js/13.e76e8c6a.js"><link rel="prefetch" href="/assets/js/14.d35f4302.js"><link rel="prefetch" href="/assets/js/15.a09c666d.js"><link rel="prefetch" href="/assets/js/16.33dc3160.js"><link rel="prefetch" href="/assets/js/17.521828eb.js"><link rel="prefetch" href="/assets/js/18.e694f17a.js"><link rel="prefetch" href="/assets/js/19.c1ec16da.js"><link rel="prefetch" href="/assets/js/20.fb6ee556.js"><link rel="prefetch" href="/assets/js/22.fcbbeb53.js"><link rel="prefetch" href="/assets/js/23.d02ba915.js"><link rel="prefetch" href="/assets/js/24.765c0f60.js"><link rel="prefetch" href="/assets/js/25.b6397f75.js"><link rel="prefetch" href="/assets/js/26.a37c5cf0.js"><link rel="prefetch" href="/assets/js/3.557dccde.js"><link rel="prefetch" href="/assets/js/4.09ee8a39.js"><link rel="prefetch" href="/assets/js/5.30fca801.js"><link rel="prefetch" href="/assets/js/6.498ab014.js"><link rel="prefetch" href="/assets/js/7.2f300486.js"><link rel="prefetch" href="/assets/js/8.d34c362f.js"><link rel="prefetch" href="/assets/js/9.60270935.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d236ad96.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Croon Liu</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Blog" class="dropdown-title"><span class="title">Blog</span> <span class="arrow down"></span></button> <button type="button" aria-label="Blog" class="mobile-dropdown-title"><span class="title">Blog</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/HTTP/" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/Vue3/" class="nav-link">
  Vue3
</a></li><li class="dropdown-item"><!----> <a href="/SSR/" class="nav-link">
  SSR
</a></li><li class="dropdown-item"><!----> <a href="/开发提效/" class="nav-link">
  开发提效
</a></li><li class="dropdown-item"><!----> <a href="/高级程序设计/" class="nav-link">
  高级程序设计
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/aboutcroon" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Blog" class="dropdown-title"><span class="title">Blog</span> <span class="arrow down"></span></button> <button type="button" aria-label="Blog" class="mobile-dropdown-title"><span class="title">Blog</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/HTTP/" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/Vue3/" class="nav-link">
  Vue3
</a></li><li class="dropdown-item"><!----> <a href="/SSR/" class="nav-link">
  SSR
</a></li><li class="dropdown-item"><!----> <a href="/开发提效/" class="nav-link">
  开发提效
</a></li><li class="dropdown-item"><!----> <a href="/高级程序设计/" class="nav-link">
  高级程序设计
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/aboutcroon" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/高级程序设计/第6章.html" class="sidebar-link">6. 集合引用类型</a></li><li><a href="/高级程序设计/第8章.html" class="sidebar-link">8. 对象、类与面向对象编程</a></li><li><a href="/高级程序设计/第10章.html" class="active sidebar-link">10. 函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-1-箭头函数" class="sidebar-link">10.1 箭头函数</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-2-函数名" class="sidebar-link">10.2 函数名</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-3-理解参数" class="sidebar-link">10.3 理解参数</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-4-没有重载" class="sidebar-link">10.4 没有重载</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-5-默认参数值" class="sidebar-link">10.5 默认参数值</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-6-参数扩展与收集" class="sidebar-link">10.6 参数扩展与收集</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-7-函数声明与函数表达式" class="sidebar-link">10.7 函数声明与函数表达式</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-8-函数作为值" class="sidebar-link">10.8 函数作为值</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-9-函数内部" class="sidebar-link">10.9 函数内部</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-10-函数属性与方法" class="sidebar-link">10.10 函数属性与方法</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-11-函数表达式" class="sidebar-link">10.11 函数表达式</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-12-递归" class="sidebar-link">10.12 递归</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-13-尾调用优化" class="sidebar-link">10.13 尾调用优化</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-14-闭包" class="sidebar-link">10.14 闭包</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-15-立即调用函数" class="sidebar-link">10.15 立即调用函数</a></li><li class="sidebar-sub-header"><a href="/高级程序设计/第10章.html#_10-16-私有变量" class="sidebar-link">10.16 私有变量</a></li></ul></li><li><a href="/高级程序设计/第11章.html" class="sidebar-link">11. Promise与异步函数</a></li><li><a href="/高级程序设计/第12章.html" class="sidebar-link">12. BOM（Browser Object Model）</a></li><li><a href="/高级程序设计/第14章.html" class="sidebar-link">14. DOM（Document Object Model）</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_10-函数"><a href="#_10-函数" class="header-anchor">#</a> 10. 函数</h1> <p>为函数实际上是对象。每个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。</p> <p>因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。</p> <p>函数通常以函数声明的方式定义，也可以以字面量形式定义。</p> <h2 id="_10-1-箭头函数"><a href="#_10-1-箭头函数" class="header-anchor">#</a> 10.1 箭头函数</h2> <p>任何可以使用函数表达式的地方，都可以使用箭头函数。</p> <p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。</p> <h2 id="_10-2-函数名"><a href="#_10-2-函数名" class="header-anchor">#</a> 10.2 函数名</h2> <p>因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20 </span>

<span class="token keyword">let</span> anotherSum <span class="token operator">=</span> sum<span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">anotherSum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20 </span>

sum <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">anotherSum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
</code></pre></div><blockquote><p>注意，使用不带括号的函数名会访问函数指针，而不会执行函数。</p></blockquote> <p>ECMAScript 6 的新特性中，所有函数对象都会暴露一个 <code>只读的 name 属性</code>，其中包含关于函数的信息。</p> <p>多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用 Function 构造函数创建的，则会标识成&quot;anonymous&quot;：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
<span class="token keyword">let</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> <span class="token function-variable function">baz</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>baz<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// baz </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//（空字符串）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// anonymous</span>
</code></pre></div><p>如果函数是一个get函数、set函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bound foo </span>

<span class="token keyword">let</span> dog <span class="token operator">=</span> <span class="token punctuation">{</span> 
 years<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> 
 <span class="token keyword">get</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>years<span class="token punctuation">;</span> 
 <span class="token punctuation">}</span><span class="token punctuation">,</span> 
 <span class="token keyword">set</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token parameter">newAge</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>years <span class="token operator">=</span> newAge<span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 

<span class="token keyword">let</span> propertyDescriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>dog<span class="token punctuation">,</span> <span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>propertyDescriptor<span class="token punctuation">.</span>get<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get age </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>propertyDescriptor<span class="token punctuation">.</span>set<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// set age</span>
</code></pre></div><h2 id="_10-3-理解参数"><a href="#_10-3-理解参数" class="header-anchor">#</a> 10.3 理解参数</h2> <p>ECMAScript 函数的参数跟大多数其他语言不同。ECMAScript 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。</p> <p>之所以会这样，主要是因为 ECMAScript 函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。</p> <p>事实上，在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 <code>arguments</code> 对象，从中取得传进来的每个参数值。arguments 对象是一个类数组对象（但不是 Array 的实例）。</p> <blockquote><p>ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</p></blockquote> <h2 id="_10-4-没有重载"><a href="#_10-4-没有重载" class="header-anchor">#</a> 10.4 没有重载</h2> <p>ECMAScript 函数不能像传统编程那样重载。在其他语言比如 Java 中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。</p> <p>如前所述，ECMAScript 函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。</p> <p><code>如果在 ECMAScript 中定义了两个同名函数，则后定义的会覆盖先定义的</code>。来看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">addSomeNumber</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token keyword">function</span> <span class="token function">addSomeNumber</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">addSomeNumber</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 300</span>
</code></pre></div><p><code>把函数名当成指针</code>也有助于理解为什么 ECMAScript 没有函数重载。在前面的例子中，定义两个同名的函数显然会导致后定义的重写先定义的。</p> <h2 id="_10-5-默认参数值"><a href="#_10-5-默认参数值" class="header-anchor">#</a> 10.5 默认参数值</h2> <p>ECMAScript 6 支持显式定义默认参数。</p> <p>在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。</p> <p>当然，跟 ES5 严格模式一样，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">makeKing</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'Henry'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 name <span class="token operator">=</span> <span class="token string">'Louis'</span><span class="token punctuation">;</span> 
 <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">King </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">makeKing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'King undefined' </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">makeKing</span><span class="token punctuation">(</span><span class="token string">'Louis'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'King Louis'</span>
</code></pre></div><h2 id="_10-6-参数扩展与收集"><a href="#_10-6-参数扩展与收集" class="header-anchor">#</a> 10.6 参数扩展与收集</h2> <p>扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。</p> <p>扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p> <h2 id="_10-7-函数声明与函数表达式"><a href="#_10-7-函数声明与函数表达式" class="header-anchor">#</a> 10.7 函数声明与函数表达式</h2> <p>事实上，JavaScript 引擎在加载数据时对这两种创建函数的方式是区别对待的。JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p> <p>来看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 没问题</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre></div><h2 id="_10-8-函数作为值"><a href="#_10-8-函数作为值" class="header-anchor">#</a> 10.8 函数作为值</h2> <h2 id="_10-9-函数内部"><a href="#_10-9-函数内部" class="header-anchor">#</a> 10.9 函数内部</h2> <p>在 ECMAScript 5 中，函数内部存在两个特殊的对象：<code>arguments</code> 和 <code>this</code>。ECMAScript 6 又新增了 <code>new.target</code> 属性。</p> <h3 id="_10-9-1-argument"><a href="#_10-9-1-argument" class="header-anchor">#</a> 10.9.1 argument</h3> <p>arguments 对象其实还有一个 <code>callee</code> 属性，是一个指向 arguments 对象所在函数的指针。</p> <h3 id="_10-9-2-this"><a href="#_10-9-2-this" class="header-anchor">#</a> 10.9.2 this</h3> <p>在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在网页的全局上下文中调用函数时，this 指向 windows）。来看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> 
 color<span class="token operator">:</span> <span class="token string">'blue'</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">sayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token function">sayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'red' </span>

o<span class="token punctuation">.</span>sayColor <span class="token operator">=</span> sayColor<span class="token punctuation">;</span> 
o<span class="token punctuation">.</span><span class="token function">sayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'blue'</span>
</code></pre></div><p>在箭头函数中，this引用的是定义箭头函数的上下文。下面的例子演示了这一点。在对sayColor()的两次调用中，this 引用的都是 window 对象，<code>因为这个箭头函数是在 window 上下文中定义的</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> 
 color<span class="token operator">:</span> <span class="token string">'blue'</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">let</span> <span class="token function-variable function">sayColor</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">sayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'red' </span>

o<span class="token punctuation">.</span>sayColor <span class="token operator">=</span> sayColor<span class="token punctuation">;</span> 
o<span class="token punctuation">.</span><span class="token function">sayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'red'</span>
</code></pre></div><p>在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">King</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>royaltyName <span class="token operator">=</span> <span class="token string">'Henry'</span><span class="token punctuation">;</span> 
 <span class="token comment">// this 引用 King 的实例</span>
 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>royaltyName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Queen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>royaltyName <span class="token operator">=</span> <span class="token string">'Elizabeth'</span><span class="token punctuation">;</span> 
 <span class="token comment">// this 引用 window 对象</span>
 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>royaltyName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token keyword">new</span> <span class="token class-name">King</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Henry </span>
<span class="token keyword">new</span> <span class="token class-name">Queen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><blockquote><p>函数名只是保存指针的变量。因此全局定义的 sayColor()函数和 o.sayColor()是同一个函数，只不过执行的上下文不同。</p></blockquote> <h3 id="_10-9-3-new-target"><a href="#_10-9-3-new-target" class="header-anchor">#</a> 10.9.3 new.target</h3> <p>ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。</p> <p>ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">King</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">throw</span> <span class="token string">'King must be instantiated using &quot;new&quot;'</span> 
 <span class="token punctuation">}</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'King instantiated using &quot;new&quot;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token keyword">new</span> <span class="token class-name">King</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// King instantiated using &quot;new&quot; </span>
<span class="token function">King</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: King must be instantiated using &quot;new&quot;</span>
</code></pre></div><h2 id="_10-10-函数属性与方法"><a href="#_10-10-函数属性与方法" class="header-anchor">#</a> 10.10 函数属性与方法</h2> <p>ECMAScript 中的函数是对象，因此有属性和方法。</p> <p>每个函数都有<code>两个属性</code>：<code>length</code> 和 <code>prototype</code>。</p> <p>其中，length 属性保存函数定义的命名参数的个数，如下例所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sayName<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
</code></pre></div><p>prototype 属性也许是 ECMAScript 核心中最有趣的部分。</p> <p>prototype 是保存引用类型所有实例方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实例共享。</p> <p>函数还有<code>两个方法</code>：<code>apply()</code> 和 <code>call()</code>。</p> <p>call()方法与 apply()的作用一样，只是传参的形式不同。第一个参数跟 apply()一样，也是 this值，而剩下的要传给被调用函数的参数则是逐个传递的。</p> <p>apply() 的第二个参数可以是 Array 的实例，但也可以是 arguments 对象。</p> <p>apply()和 call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内 this值的能力。考虑下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span> 
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> 
 color<span class="token operator">:</span> <span class="token string">'blue'</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">sayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token function">sayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red </span>
<span class="token function">sayColor</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red </span>
<span class="token function">sayColor</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// red </span>
<span class="token function">sayColor</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blue</span>
</code></pre></div><p>ECMAScript 5 出于同样的目的定义了一个新方法：<code>bind()</code>。bind() 方法会创建一个新的函数实例，其 this 值会被绑定到传给 bind() 的对象。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> 
 color<span class="token operator">:</span> <span class="token string">'blue'</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">sayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token keyword">let</span> objectSayColor <span class="token operator">=</span> <span class="token function">sayColor</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">objectSayColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blue</span>
</code></pre></div><p>对函数而言，继承的方法 <code>toLocaleString()</code>和 <code>toString()</code>始终返回函数的代码。返回代码的具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。继承的方法 <code>valueOf()</code>返回函数本身。</p> <h2 id="_10-11-函数表达式"><a href="#_10-11-函数表达式" class="header-anchor">#</a> 10.11 函数表达式</h2> <h2 id="_10-12-递归"><a href="#_10-12-递归" class="header-anchor">#</a> 10.12 递归</h2> <p>递归函数通常的形式是一个函数通过名称调用自己，如下面的例子所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
 	<span class="token keyword">return</span> num <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>也可以把函数名称替换成 arguments.callee，可以确保无论通过什么变量调用这个函数都不会出问题。因此在编写递归函数时，arguments.callee 是引用当前函数的首选。</p> <p>不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。此时，可以使用命名函数表达式（named function expression）达到目的。</p> <h2 id="_10-13-尾调用优化"><a href="#_10-13-尾调用优化" class="header-anchor">#</a> 10.13 尾调用优化</h2> <p>ECMAScript 6 规范新增了一项内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 尾调用</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 ES6 优化之前，执行这个例子会在内存中发生如下操作。</p> <p>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</p> <p>(2) 执行 outerFunction 函数体，到 return 语句。计算返回值必须先计算 innerFunction。</p> <p>(3) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。</p> <p>(4) 执行 innerFunction 函数体，计算其返回值。</p> <p>(5) 将返回值传回 outerFunction，然后 outerFunction 再返回值。</p> <p>(6) 将栈帧弹出栈外。</p> <p>在 ES6 优化之后，执行这个例子会在内存中发生如下操作。</p> <p>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</p> <p>(2) 执行 outerFunction 函数体，到达 return 语句。为求值返回语句，必须先求值 innerFunction。</p> <p>(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction</p> <p>的返回值。</p> <p>(4) 弹出 outerFunction 的栈帧。</p> <p>(5) 执行到 innerFunction 函数体，栈帧被推到栈上。</p> <p>(6) 执行 innerFunction 函数体，计算其返回值。</p> <p>(7) 将 innerFunction 的栈帧弹出栈外。</p> <p>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</p> <h2 id="_10-14-闭包"><a href="#_10-14-闭包" class="header-anchor">#</a> 10.14 闭包</h2> <p>匿名函数经常被人误认为是闭包（closure）。<code>闭包指的是那些引用了另一个函数作用域中变量的函数</code>，通常是在嵌套函数中实现的。</p> <p>比如，下面代码的 value1 和 value2：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createComparisonFunction</span><span class="token punctuation">(</span><span class="token parameter">propertyName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">object1<span class="token punctuation">,</span> object2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	 <span class="token keyword">let</span> value1 <span class="token operator">=</span> object1<span class="token punctuation">[</span>propertyName<span class="token punctuation">]</span><span class="token punctuation">;</span> 
	 <span class="token keyword">let</span> value2 <span class="token operator">=</span> object2<span class="token punctuation">[</span>propertyName<span class="token punctuation">]</span><span class="token punctuation">;</span> 
 <span class="token keyword">if</span> <span class="token punctuation">(</span>value1 <span class="token operator">&lt;</span> value2<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 	 <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value1 <span class="token operator">&gt;</span> value2<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 	 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
 	 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>这两行代码位于内部函数（匿名函数）中，其中引用了外部函数的变量 propertyName。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含 createComparisonFunction() 函数的作用域。要理解为什么会这样，可以想想第一次调用这个函数时会发生什么。</p> <p>理解作用域链创建和使用的细节对理解闭包非常重要。</p> <p>在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。</p> <p>在函数执行时，要从作用域链中查找变量，以便读、写值。来看下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token parameter">value1<span class="token punctuation">,</span> value2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">if</span> <span class="token punctuation">(</span>value1 <span class="token operator">&lt;</span> value2<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 	 <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value1 <span class="token operator">&gt;</span> value2<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 	 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
 	 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 

<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。</p> <h2 id="_10-15-立即调用函数"><a href="#_10-15-立即调用函数" class="header-anchor">#</a> 10.15 立即调用函数</h2> <h2 id="_10-16-私有变量"><a href="#_10-16-私有变量" class="header-anchor">#</a> 10.16 私有变量</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/高级程序设计/第8章.html" class="prev">
        8. 对象、类与面向对象编程
      </a></span> <span class="next"><a href="/高级程序设计/第11章.html">
        11. Promise与异步函数
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.356218c2.js" defer></script><script src="/assets/js/2.1547bbba.js" defer></script><script src="/assets/js/21.f4053037.js" defer></script>
  </body>
</html>
